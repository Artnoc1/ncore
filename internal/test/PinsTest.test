#include <iostream>
#include <sstream>
#include <streambuf>
#include <cxxtest/TestSuite.h>
#include <Pins.h>
#include <Parser.h>
#include <Dispatcher.h>

using namespace std;

const int LOW = 0;
const int HIGH = 1;

class PinsTestSuite: public CxxTest::TestSuite
{
  Pins pins;
  Dispatcher commands;
  stringstream test_buffer;
  streambuf* cout_sbuf;
  static int isr_called_count;
public:
  void setUp()
  {
    pins.clear();
    commands.clear();
    test_buffer.str(string());
    cout_sbuf = NULL;
    pins.addCommandsTo(commands);
    isr_called_count = 0;
  }
  static void isr(void)
  {
    ++isr_called_count;
  }
  static void isr_large(void)
  {
    isr_called_count += 5;
  }
  int countSubStrings( const string& whole, const string& partial )
  {
    size_t skip_count = partial.size();

    std::string::size_type and_pos( 0 );
    int count(0);
    while ( and_pos!=std::string::npos )
    {
      and_pos = whole.find(partial, and_pos );
      if ( and_pos != std::string::npos )
      {
        ++count;
        and_pos += skip_count;
      }
    }
    return count;
  }

  void testEmpty( void )
  {
    int value = pins.digitalRead(0);

    TS_ASSERT_EQUALS( value, LOW );
  }
  void testSetDigital( void )
  {
    pins.hwSetDigital(0,HIGH);
    int value = pins.digitalRead(0);

    TS_ASSERT_EQUALS( value, HIGH );
  }
  void testSetAnalog( void )
  {
    pins.hwSetAnalog(0,512);
    int value = pins.analogRead(0);

    TS_ASSERT_EQUALS( value, 512 );
  }
  void testAttachInterrupt( void )
  {
    pins.attachInterrupt( 0, isr );
    pins.hwTriggerInterrupt( 0 );

    TS_ASSERT_EQUALS( isr_called_count, 1 );
  }
  void testCallsCorrectInterrupt( void )
  {
    pins.attachInterrupt( 0, isr );
    pins.attachInterrupt( 1, isr_large );
    pins.hwTriggerInterrupt( 1 );

    TS_ASSERT_EQUALS( isr_called_count, 5 );
  }
  void testAttachInterruptTooHigh( void )
  {
    pins.attachInterrupt( 10, isr );
    TS_ASSERT_THROWS_ANYTHING( pins.hwTriggerInterrupt( 10 ) );
  }
  void testOverrideInterrupt( void )
  {
    pins.attachInterrupt( 0, isr );
    pins.attachInterrupt( 0, isr_large );
    pins.hwTriggerInterrupt( 0 );

    TS_ASSERT_EQUALS( isr_called_count, 5 );
  }
  void testDetachInterrupt( void )
  {
    pins.attachInterrupt( 0, isr );
    pins.detachInterrupt( 0 );

    TS_ASSERT_THROWS_ANYTHING( pins.hwTriggerInterrupt( 0 ) );
  }
  void testAddCommands( void )
  {
    int numcommands = commands.size();

    TS_ASSERT( numcommands > 0 );
  }
  void testRunCommand( void )
  {
    startCoutCapture();
    bool ok = commands.execute(Parser("pins"));
    string output = endCoutCapture();

    TS_ASSERT_EQUALS( ok, true );
  }
  void startCoutCapture( void )
  {
    // Capture the input to a test buffer
    cout_sbuf = std::cout.rdbuf(); // save original sbuf
    cout.rdbuf(test_buffer.rdbuf()); // redirect 'cout' to a 'fout'
  }
  string endCoutCapture( void )
  {
    // Restore the output stream
    cout.rdbuf(cout_sbuf); // restore the original stream buffer

    return test_buffer.str();
  }
  void testRunCommandPinsEmpty( void )
  {
    startCoutCapture();
    bool ok = commands.execute(Parser("pins"));
    string output = endCoutCapture();
    int num_zeroes = countSubStrings(output,":0");

    TS_ASSERT_EQUALS( num_zeroes, 28 );
  }
  void testRunCommandPinsSomeSet( void )
  {
    pins.hwSetDigital(0,HIGH);
    pins.hwSetAnalog(0,512);

    startCoutCapture();
    bool ok = commands.execute(Parser("pins"));
    string output = endCoutCapture();
    int num_zeroes = countSubStrings(output,":0");

    TS_ASSERT_EQUALS( num_zeroes, 26 );
  }
  void testCommandPinSet( void )
  {
    commands.execute(Parser("pin 5 high"));

    TS_ASSERT_EQUALS( pins.digitalRead(5), HIGH );
  }
  void testCommandPinSetAndBack( void )
  {
    commands.execute(Parser("pin 5 high"));
    commands.execute(Parser("pin 5 low"));

    TS_ASSERT_EQUALS( pins.digitalRead(5), LOW );
  }
  void testCommandPinSetExceptions_1( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin")) );
  }
  void testCommandPinSetExceptions_2( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin 100 high")) );
  }
  void testCommandPinSetExceptions_3( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin 5")) );
  }
  void testCommandPinSetExceptions_4( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin 5 something")) );
  }
  void testCommandPinSetExceptions_5( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin 5 high something")) );
  }
  void testCommandPinSetExceptions_6( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin something high")) );
  }
  void testCommandAnalogSet( void )
  {
    commands.execute(Parser("pin a5 512"));

    TS_ASSERT_EQUALS( pins.analogRead(5), 512 );
  }
  void testCommandAnalogSetTwice( void )
  {
    commands.execute(Parser("pin a0 512"));
    commands.execute(Parser("pin a0 1"));

    TS_ASSERT_EQUALS( pins.analogRead(0), 1 );
  }
  void testCommandAnalogPinSetExceptions_1( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin a5")) );
  }
  void testCommandAnalogPinSetExceptions_2( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin a5 high")) );
  }
  void testCommandAnalogPinSetExceptions_3( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin a5 1000 something")) );
  }
  void testCommandAnalogPinSetExceptions_4( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin a1000 1000")) );
  }
  void testCommandAnalogPinSetExceptions_5( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("pin a5 2000")) );
  }
  void testCommandIrq( void )
  {
    pins.attachInterrupt( 1, isr );
    commands.execute(Parser("irq 1"));

    TS_ASSERT_EQUALS( isr_called_count, 1 );
  }
  void testCommandIrqExceptions( void )
  {
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("irq 100")) );
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("irq something")) );
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("irq")) );
  }
};

// Extra tests to dig deep into the unexposed internals of Logger
// in pursuit of 100% code coverage
class PinsInternalTestSuite: public CxxTest::TestSuite
{
  class PinsInternal: Pins
  {
  public:
    void bad_static_pins(void)
    {
      // This is bad.  Don't do this in real life.
      Pins::reset();
      Pins::static_command_pins(vector<string>());
    }
    void bad_static_pin(void)
    {
      // This is bad.  Don't do this in real life.
      Pins::reset();
      Pins::static_command_pin(vector<string>());
    }
    void bad_static_irq(void)
    {
      // This is bad.  Don't do this in real life.
      Pins::reset();
      Pins::static_command_irq(vector<string>());
    }
  };
public:
  void testBadStaticCommands(void)
  {
    TS_ASSERT_THROWS_ANYTHING( PinsInternal().bad_static_pins() );
    TS_ASSERT_THROWS_ANYTHING( PinsInternal().bad_static_pin() );
    TS_ASSERT_THROWS_ANYTHING( PinsInternal().bad_static_irq() );
  }
};

int PinsTestSuite::isr_called_count;


// vim:cin:ai:sts=2 sw=2 ft=cpp
