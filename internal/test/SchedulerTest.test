// STL includes
#include <vector>
#include <string>
#include <iostream>
#include <stdexcept>

// C includes

// Library includes
#include <cxxtest/TestSuite.h>

// Project includes
#include <SketchThread.h>
#include <Parser.h>
#include <Dispatcher.h>
#include <Clock.h>
#include <IDispatchable.h>
#include <Logger.h>
#include <Scheduler.h>
#include <OutputCapture.h>

using namespace std;

extern ostream& operator<<(ostream& os, const Logger& log);
extern "C" void mock_time_reset(void);
extern Logger global_logger;

struct TestAction: public IDispatchable
{
  int called;
  TestAction(void): called(0) {}
  std::string& getCommands(void) const { static std::string commands = "test"; return commands; }
  bool runCommand( const Parser& p )
  {
    cerr << "runcommand..." << endl;
    global_logger.sketch("TEST","TestAction %i",p.size());
    bool result = false;
    if ( p.at(0) == "test" )
    {
      ++called;
      if ( p.size() > 1 && p.at(1) == "more" )
	called += 4;
      result = true;
    }
    else if ( p.at(0) == "help" && p.at(1) == "test" )
    {
      cout << "test -- do nothing and return true" << endl;
      result = true;
    }
    return result;
  }
};

Dispatcher global_dispatch;
Scheduler global_sched(global_dispatch,global_logger);

void sched_test_main(void)
{
  cerr << "starting..." << endl;
  bool done = false;
  while(!done)
  {
    cerr << "running..." << endl;
    global_sched.runonce();

    if ( ! global_sched.size() )
      cerr << "empty" << endl;
    done = ! global_sched.size();
  }
  cerr << "done..." << endl;
}

class SchedulerTestSuite: public CxxTest::TestSuite
{
  Scheduler sched;
  Dispatcher dispatch;
  Clock clock;
  TestAction action;
  OutputCapture cap;
public:
  SchedulerTestSuite(void): sched(dispatch,global_logger)
  {
  }
  void setUp()
  {
    mock_time_reset();
    clock = Clock();
    dispatch.clear();
    sched.clear();
    action = TestAction();
    dispatch.add(&action);
    dispatch.add(&sched);
    global_logger.clear();
    dispatch.add(&global_logger);
    cap.clear();
  }

  void testEmpty( void )
  {
    TS_ASSERT_EQUALS( sched.size(), 0 );
  }
  void testAdd( void )
  {
    sched.add(1000,string("test")) ;
    TS_ASSERT_EQUALS( sched.size(), 1 );
  }
  void testNotRun( void )
  {
    sched.add(1000,string("test"));
    sched.runonce(); // protected!!
    TS_ASSERT_EQUALS( action.called, 0 );
  }
  void testRun( void )
  {
    sched.add(1000,string("test"));
    clock.delay(1100);
    sched.runonce(); // protected!!
    TS_ASSERT_EQUALS( action.called, 1 );
  }
  void testRunTwice( void )
  {
    sched.add(1000,string("test"));
    sched.add(2000,string("test more"));
    clock.delay(1100);
    sched.runonce(); // protected!!
    TS_ASSERT_EQUALS( action.called, 1 );
    clock.delay(1100);
    sched.runonce(); // protected!!
    TS_ASSERT_EQUALS( action.called, 6 );
  }
  void testConcurrent( void )
  {
    cerr << "[IN:" << __FUNCTION__ ;
    global_dispatch.add(&action);
    global_logger.setClock(clock);
    global_logger.setRate(1);
    SketchThread t(1);
    t.startCustom(sched_test_main);
    
    timespec tv;
    tv.tv_sec = 0;
    tv.tv_nsec = 500000L;
    nanosleep(&tv,NULL);
    tv.tv_nsec = 60000000L;

    cerr << "adding..." << endl;
    global_sched.add(100,string("test"));
    nanosleep(&tv,NULL);
    cerr << "adding..." << endl;
    global_sched.add(200,string("test more"));
    cerr << "adding..." << endl;
    global_sched.add(300,string("test more"));

    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);
    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);
    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);
    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);
    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);
    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);
    cerr << "delay..." << endl;
    clock.delay(60);
    nanosleep(&tv,NULL);

    tv.tv_sec = 0;
    tv.tv_nsec = 500000L;
    nanosleep(&tv,NULL);

    t.waitToFinish();

    cerr << global_logger;
     
    TS_ASSERT_EQUALS( global_logger.lines_contain("TestAction"), 3 );
    cerr << ":OUT]" << endl; 
  }
  void testAtCommandOk( void )
  {
    bool ok = dispatch.execute("at 1 list");
    TS_ASSERT_EQUALS( ok, true );
  }
  void testAtCommandWorks( void )
  {
    dispatch.execute("at 1 test");
    clock.delay(2);
    sched.runonce(); // protected!!
    TS_ASSERT_EQUALS( action.called, 1 );
  }
  void testAtCommandTwice( void )
  {
    cap.start();
    dispatch.execute("at 1 test");
    dispatch.execute("at 2 list");
    clock.delay(3);
    sched.runonce(); // protected!!
    sched.runonce(); // protected!!
    cap.stop();
    
    TS_ASSERT_EQUALS( cap.contains("AT"), 2 );
    TS_ASSERT_EQUALS( cap.contains("TEST"), 1 );

  }
};
// vim:cin:ai:sts=2 sw=2 ft=cpp
