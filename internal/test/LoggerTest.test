#include <cxxtest/TestSuite.h>
#include <pthread.h>
#include <Logger.h>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <streambuf>
#include <Parser.h>
#include <Dispatcher.h>

using namespace std;

extern "C" void init(void);

class LoggerTestSuite: public CxxTest::TestSuite
{
  Logger log;
  Dispatcher commands;
  Parser parser;
  stringstream test_buffer;
  streambuf* cout_sbuf;
public:
  void setUp()
  {
    test_buffer.str(string());
    cout_sbuf = std::cout.rdbuf(); // save original sbuf
    log.clear();
    parser.clear();
    log.addCommandsTo(commands);

    startCoutCapture();
    init();
    endCoutCapture();
  }
  void tearDown()
  {
    endCoutCapture();
  }
  void startCoutCapture( void )
  {
    // Capture the input to a test buffer
    test_buffer.str(string());
    cout_sbuf = std::cout.rdbuf(); // save original sbuf
    cout.rdbuf(test_buffer.rdbuf()); // redirect 'cout' to a 'fout'
  }
  string endCoutCapture( void )
  {
    // Restore the output stream
    cout.rdbuf(cout_sbuf); // restore the original stream buffer

    return test_buffer.str();
  }
  int countSubStrings( const string& whole, const string& partial )
  {
    size_t skip_count = partial.size();

    std::string::size_type and_pos( 0 );
    int count(0);
    while ( and_pos!=std::string::npos )
    {
      and_pos = whole.find(partial, and_pos );
      if ( and_pos != std::string::npos )
      {
        ++count;
        and_pos += skip_count;
      }
    }
    return count;
  }

  void testEmpty( void )
  {
    TS_ASSERT_EQUALS( log.size(), 0 );
  }
  void testAdd( void )
  {
    log.add("Test1");
    log.add("Test12");
    log.add("Test123");
    TS_ASSERT_EQUALS( log.size(), 3 );
    TS_ASSERT( log.at(0).find("Test1") != string::npos );
  }
  void testVargs( void )
  {
    log.add("Test %02i",1);
    TS_ASSERT( log.at(0).find("Test 01") != string::npos );
  }
  void testListCommandOk( void )
  {
    parser.parse("list");

    startCoutCapture();
    bool ok = commands.execute(parser);
    string output = endCoutCapture();

    TS_ASSERT_EQUALS( ok, true );
  }
  void testListExceptions_1( void )
  {
    // Currently not implemented, so should throw
    startCoutCapture();
    TS_ASSERT_THROWS_ANYTHING( commands.execute(Parser("list 1000")) );
  }
  void testListCommandWorks( void )
  {
    log.add("Test1");
    log.add("Test12");
    log.add("Test123");

    parser.parse("list");

    startCoutCapture();
    commands.execute(parser);
    string output = endCoutCapture();

    TS_ASSERT_EQUALS( countSubStrings(output,"NCORE"), 3 );
  }
  void todo_testListCommandRegexp( void )
  {
    log.add("Test1");
    log.add("Test12");
    log.add("Test123");

    parser.parse("list /T.*12/");

    startCoutCapture();
    commands.execute(parser);
    string output = endCoutCapture();

    TS_ASSERT_EQUALS( countSubStrings(output,"NCORE"), 2 );
  }
  static void * write_logs(void* pv)
  {
    LoggerTestSuite* p = reinterpret_cast<LoggerTestSuite*>(pv);

    int i = 50;
    while (i--)
      p->log.add("Background thread %02i",i);
  }
  void testThreadSafe( void )
  {
    pthread_t bg_thread;
    int err = pthread_create( &bg_thread, NULL, write_logs, this );
    TS_ASSERT_EQUALS( err, 0 );
    usleep(5);
    int i = 50;
    while (i--)
      log.add("Foreground thread");
    pthread_join( bg_thread, NULL );

    startCoutCapture();
    commands.execute(Parser("list"));
    endCoutCapture();
    TS_ASSERT_EQUALS( countSubStrings(test_buffer.str(),"Background"), 50 );
    TS_ASSERT_EQUALS( countSubStrings(test_buffer.str(),"Foreground"), 50 );
  }
  void testThreadSafeListing( void )
  {
    pthread_t bg_thread;
    int err = pthread_create( &bg_thread, NULL, write_logs, this );
    TS_ASSERT_EQUALS( err, 0 );
    startCoutCapture();
    usleep(5);
    int i = 7;
    while (i--)
    {
      cout << i << endl;
      commands.execute(Parser("list"));
      usleep(5);
    }
    pthread_join( bg_thread, NULL );
    endCoutCapture();
    
    TS_ASSERT( countSubStrings(test_buffer.str(),"Background") > 200 );
  }
};

// Extra tests to dig deep into the unexposed internals of Logger
// in pursuit of 100% code coverage
class LoggerInternalTestSuite: public CxxTest::TestSuite
{
  class LoggerInternal: Logger
  {
  public:
    void bad_static_list(void)
    {
      // This is bad.  Don't do this in real life.
      Logger::reset();
      Logger::static_command_list(vector<string>());
    }
  };
public:
  void testBadStaticList(void)
  {
    TS_ASSERT_THROWS_ANYTHING( LoggerInternal().bad_static_list() );
  }
};

// vim:cin:ai:sts=2 sw=2 ft=cpp
