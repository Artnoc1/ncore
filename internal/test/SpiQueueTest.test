#include <vector>
#include <string>

#include <cxxtest/TestSuite.h>

#include <SketchThread.h>
#include <SpiQueue.h>

using namespace std;

static QueueTS<string> q;

extern ostream& operator<<(ostream& os, const Logger& log);
  
void semaphores_test_main(void)
{
  bool done = false;
  while(!done)
  {
    if ( ! q.available() )
      global_logger.sketch("QPOP","Blocking...");
    string s = q.pop();
    global_logger.sketch("QPOP",s.c_str());

    done = ( s == "quit" );
  }
}

class SpiQueueTestSuite: public CxxTest::TestSuite
{
  SpiQueue spiq;
  Logger logger;
public:
  SpiQueueTestSuite(void): spiq(logger)
  {
  }
  void setUp()
  {
    logger.clear();
    q.clear();
    //spiq.clear();
  }

  void testEmpty( void )
  {
    TS_ASSERT_EQUALS( q.available(), false );
  }

  void testQueueSimple( void )
  {
    q.push("test");

    TS_ASSERT_EQUALS( q.pop(), "test" );
  }
  void testQueueAvailable( void )
  {
    q.push("test");
  
    TS_ASSERT_EQUALS( q.available(), true );
  }
  void testQueueEmptyThenAvailable( void )
  {
    q.push("test");
    q.pop();
  
    TS_ASSERT_EQUALS( q.available(), false );
  }
  void testQueueDouble( void )
  {
    q.push("first");
    q.push("second");

    TS_ASSERT_EQUALS( q.pop(), "first" );
    TS_ASSERT_EQUALS( q.pop(), "second" );
  }
  void testQueueConcurrent( void )
  {
    cerr << "[IN:" << __FUNCTION__ ;
    SketchThread t(1);
    t.startCustom(semaphores_test_main);
    
    timespec tv;
    tv.tv_sec = 0;
    tv.tv_nsec = 500000L;
    nanosleep(&tv,NULL);

    global_logger.internal("QPUS","first");
    q.push("first");
    global_logger.internal("QPUS","second");
    q.push("second");
    global_logger.internal("QPUS","third");
    q.push("third");

    tv.tv_sec = 0;
    tv.tv_nsec = 500000L;
    nanosleep(&tv,NULL);

    q.push("quit");
    global_logger.internal("QPUS","quit");
    
    t.waitToFinish();

    //cerr << logger;
     
    TS_ASSERT_EQUALS( global_logger.lines_contain("first"), 2 );
    TS_ASSERT_EQUALS( global_logger.lines_contain("quit"), 2 );
    cerr << ":OUT]" << endl; 
  }
  void testSpiTransferRead( void )
  {
    spiq.hwEnqueue(0xfe);
    uint8_t in = spiq.transfer(-1);

    TS_ASSERT_EQUALS( in, 0xfe );
  }
  void testSpiTransferLogging( void )
  {
    spiq.hwEnqueue(0xfe);
    spiq.transfer(-1);

    TS_ASSERT_EQUALS( logger.lines_contain("fe"), 1 );
  }
};
// vim:cin:ai:sts=2 sw=2 ft=cpp
